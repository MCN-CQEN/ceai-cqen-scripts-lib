name: "créer une application dans ArgoCD"
description: "créer une application dans ArgoCD si elle n'existe pas"

inputs:
  role_to_assume:
    description: "Nom du rôle AWS"
    required: true
  aws_region:
    description: "Région AWS"
    required: true
    default: "ca-central-1"
  argocd_server:
    description: "URL du serveur Argo CD"
    required: true
  argocd_username:
    description: "Nom d'utilisateur Argo CD"
    default: "admin"
  sm_argocd_admin_creds_secret_name:
    description: "Nom du secret dans Secrets Manager"
    required: true
  sm_argocd_admin_creds_secret_key:
    description: "Nom du secret dans Secrets Manager"
    required: true    
  app_project_name:
    description: "Le nom du projet où l'application sera déployée"
  app_name:
    description: "Le nom de l'application"
    required: true
  app_dest_namespace: 
    description: "Espace de destination du projet Argo CD"
    default: "argocd"
  app_manifest_repo:
    description: "URL du dépôt Git pour le manifeste de l'application"
    required: true
  app_manifest_repo_branch:
    description: "Récupérer la branche du dépôt Git pour le manifeste de l'application"
    default: "main"
  app_manifest_path:
    description: "Chemin du manifeste de l'application"
    required: true

runs:
  using: "composite"
  steps:

    # Secrets manager pour le mdp de l'admin d'ArgoCD

    - name: Checkout code
      uses: actions/checkout@v3        

    - name: "Configure AWS credentials for role ${{ inputs.role_to_assume }}"
      uses: aws-actions/configure-aws-credentials@v4          
      with:                
        role-to-assume: ${{ inputs.role_to_assume }}
        role-session-name: GitHub_to_AWS_via_FederatedOIDC
        aws-region: ${{ inputs.aws_region }}

    - name: Obtenir le secret du mdp de l'admin d'ArgoCD dans secretsmanager
      id: secretsmanager
      uses: aws-actions/aws-secretsmanager-get-secrets@v1 
      with:
        secret-ids: |
          ARGOCD_ADM_CREDS,${{ inputs.sm_argocd_admin_creds_secret_name }}
        #name or ARN of the secret
        parse-json-secrets: true # Set to true if your secret value is JSON

    - name: Verify secret existence ${{ inputs.sm_argocd_admin_creds_secret_key}}
      shell: bash    
      run: |
        SECRET_CONCATENATED_NAME="ARGOCD_ADM_CREDS_${{ inputs.sm_argocd_admin_creds_secret_key }}"
        echo "SECRET_CONCATENATED_NAME:  " $SECRET_CONCATENATED_NAME
        SECRET_VALUE=${!SECRET_CONCATENATED_NAME}

        # Set it as an environment variable for subsequent steps
        echo "ADM_PWD=${SECRET_VALUE}" >> $GITHUB_ENV
        
        echo "The value of ${SECRET_CONCATENATED_NAME} is: ${SECRET_VALUE}, from env: ${{ env.ADM_PWD }}"
        if [ -n "$SECRET_VALUE" ]; then
          echo "$SECRET_CONCATENATED_NAME exists and its value is: $SECRET_VALUE"
        else
          #echo "Secret ${{ inputs.sm_argocd_admin_creds_secret_name }} exists and is available."
          echo "Error: Secret ${{ inputs.sm_argocd_admin_creds_secret_name }} or its key ${{ inputs.sm_argocd_admin_creds_secret_key }} not found in AWS Secrets Manager."
          exit 1          
        fi    

    - name: Vérifier et installer ArgoCD CLI
      shell: bash    
      run: |
        if ! command -v argocd &> /dev/null
        then
            echo "ArgoCD CLI not found, installing..."
            # Download the latest ArgoCD CLI for Linux AMD64
            # You can find the latest version from https://github.com/argoproj/argo-cd/releases/latest
            LATEST_VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep "tag_name" | cut -d : -f 2,3 | tr -d \" | tr -d , | awk '{print $1}')
            wget https://github.com/argoproj/argo-cd/releases/download/${LATEST_VERSION}/argocd-linux-amd64
            sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
            rm argocd-linux-amd64
            echo "ArgoCD CLI installed."
        else
            echo "ArgoCD CLI is already installed."
        fi
        argocd version --client # Verify installation

    - name: Login au Argo CD
      shell: bash
      run: |  
        argocd login ${{ inputs.argocd_server }} --username ${{ inputs.argocd_username }} --password "${{ env.ADM_PWD }}" --grpc-web --insecure

    - name: Check si le projet Argo CD existe
      id: check_project
      continue-on-error: true # This ensures the step won't fail the workflow if the command errors
      shell: bash
      run: |
        if argocd proj get ${{ inputs.app_project_name }}; then
          echo "project_exists=true" >> $GITHUB_OUTPUT
        else
          echo "project_exists=false" >> $GITHUB_OUTPUT
        fi
        # Attempt to get the project and capture the exit code
        # argocd proj get ${{ inputs.app_name }} &> /dev/null
        # echo "exit_code=$?" >> $GITHUB_OUTPUT    
    
    - name: Quitter si le projet n'existe pas
      shell: bash
      run: |
        if ${{steps.check_project.outputs.project_exists == 'false'}}; then
          echo "Projet ${{inputs.app_project_name}} does not exist, exit workflow. Contactez l'administrateur de projets pour créer le projet"
          exit 0
        else
          echo "Project ${{inputs.app_project_name}} exists, will continue"
        fi

    - name: Check if Argo CD application exists and create if not
      shell: bash
      # env:
      #   APP_NAME: my-app # Replace with your application name
      #   REPO_URL: https://github.com/your-org/your-repo.git # Replace with your Git repository URL
      #   PATH_IN_REPO: k8s/my-app # Replace with the path to your application manifests in the repo
      #   DEST_NAMESPACE: default # Replace with your target namespace
      #   DEST_SERVER: https://kubernetes.default.svc # Replace with your target cluster API server
      run: |
        if ! argocd app get ${{inputs.app_name}} &> /dev/null; then
          echo "Argo CD application '${{inputs.app_name}}' does not exist. Creating it..."
          argocd app create ${{inputs.app_name}} \
            --repo ${{inputs.app_manifest_repo}} \
            --revision ${{ inputs.app_manifest_repo_branch }} \
            --path ${{inputs.app_manifest_path}} \
            --dest-namespace ${{inputs.app_dest_namespace}} \
            --dest-server https://kubernetes.default.svc \
            --sync-policy automated # Or your desired sync policy \
            --grpc-web
        else
          echo "Argo CD application '${{inputs.app_name}}' already exists. Skipping creation."
        fi        

    
      
    # - name: Create Argo CD app if it doesn't exist
    #   shell: bash
    #   #if: steps.check_project.outputs.project_exists == 'false'        
    #   #if: steps.check_project.outputs.exit_code != '0' #project doesn't exist
    #   #if: failure() # previous step failed
    #   #if: ${{ failure() }} # This step runs only if previous step failed
    #   run: |
    #       echo "project does not exist. Will be created."        
    #       argocd app create ${{ inputs.app_name }} \
    #       --repo ${{ inputs.app_manifest_repo }} \
    #       --revision ${{ inputs.app_manifest_repo_branch }} \
    #       --path ${{ inputs.app_manifest_path }} \
    #       --dest-namespace ${{ inputs.app_dest_namespace }} \
    #       --dest-server https://kubernetes.default.svc \
    #       --directory-recurse \
    #       --upsert \
    #       --grpc-web
    #       # --sync-policy automatic 


    - name: Assert Argo CD Application Health
      shell: bash
      run: echo "final step, application ${{ inputs.app_name }} should have been created"  

    # - name: Assert Argo CD Application Health
    #   shell: bash
    #   run: argocd app wait ${{ inputs.app_name}} --health --timeout 300        